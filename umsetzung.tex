Für das Speichern der Zustände der Puzzleaufgabe nutzen wir einen zweidimensionalen Array. 
Da die Größe dieses Arrays zum Zeitpunkt der Kompilierung unbekannt ist, nutzen wir pointer-to-pointer.
Das Hauptverfahren läuft in der Funktion \texttt{void loese(char **f))} der Hauptklasse \texttt{rahmen}.
Als weitere Hilfsfunktionen gibt es \texttt{void rotieren\_links(char **f)} sowie \texttt{void rotieren\_rechts(char **f)}. Diese setzen die Rotation eines Rahmens nach links oder rechts um.
Innerhalb dieser Funktionen wird auf die Funktion \texttt{void gravitation(char **f)} zurückgegriffen. Diese simuliert den Fall der Steine im vorher gedrehten Puzzle.

\texttt{bool ist\_loesung(char **f)} überprüft, ob der übergebene Zustand eine Lösung darstellt.

Zur Umsetzung der in der Lösungsidee erläuterten Listenstruktur nutzen wir einen std::vector \\\texttt{std::vector<std::vector<char **> > baum}.
In der ersten Dimension werden in diesem std::vector die jeweiligen Listeneinträge gespeichert, in der zweiten werden die möglichen Zustände der Puzzleaufgabe gespeichert. 
Auf die Aufgabe übertragen, iteriert die erste Dimension über die Drehungen während die zweite über die jeweils möglichen Zustände der Puzzleaufgabe zu diesem Zeitpunkt iteriert.

Um das Überprüfen auf das Vorhandensein eines Zustandes zu beschleunigen, berechnen wir für jeden Zustand der Puzzleaufgabe einen Hashwert.
Über diesen lassen sich  die Zustände effizienter vergleichen. Zum Speichern der Hashwerte nutzen 
wir einen mehrdimensionalen std::vector \texttt{std::vector<std::vector<char *> > hashs}. Dieser hat die gleiche Strukutur wie der std::vector \texttt{baum}.

Mit dem Hashverfahren und einer effizienteren Suchlogik konnte die Laufzeit bei rotation3\_03.txt um den Faktor 3 verringert werden.
Die Suchlogik haben wir dahingehend verändert, dass zunächst die jeweils letzten Zustände verglichen werden, da ähnliche Zustände wahrscheinlich weniger Rotationsvorgänge zurückliegen. So können wir schneller neue zustände als schon vorhanden ausschließen.

Die zur Umsetzung der Gravitation genutzte Funktion \texttt{void gravitation(char **f)} geht den übergebenen Zustand der Puzzleaufgabe von unten nach oben durch.
Trifft der Algorithmus auf einen Teil eines Steins, wird zunächst Größe dieses Steins bestimmt. Befinden sich unter dem Stein keine Hindernisse, 
wird dieser möglichst weit nach unten versetzt. Hierbei speichert das Programm, welche Steine es bereits versetzt hat, sodass bereits versetzte Steine ignoriert werden. So werden Endlosschleifen verhindert.